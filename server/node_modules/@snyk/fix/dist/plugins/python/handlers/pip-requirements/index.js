"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectFileForPinning = exports.applyAllFixes = exports.fixIndividualRequirementsTxt = exports.getRequiredData = exports.pipRequirementsTxt = void 0;
const debugLib = require("debug");
const pathLib = require("path");
const sortBy = require('lodash.sortby');
const groupBy = require('lodash.groupby');
const update_dependencies_1 = require("./update-dependencies");
const missing_remediation_data_1 = require("../../../../lib/errors/missing-remediation-data");
const missing_file_name_1 = require("../../../../lib/errors/missing-file-name");
const is_supported_1 = require("./is-supported");
const no_fixes_applied_1 = require("../../../../lib/errors/no-fixes-applied");
const extract_version_provenance_1 = require("./extract-version-provenance");
const requirements_file_parser_1 = require("./update-dependencies/requirements-file-parser");
const standardize_package_name_1 = require("./update-dependencies/standardize-package-name");
const contains_require_directive_1 = require("./contains-require-directive");
const debug = debugLib('snyk-fix:python:requirements.txt');
async function pipRequirementsTxt(entities, options) {
    debug(`Preparing to fix ${entities.length} Python requirements.txt projects`);
    const handlerResult = {
        succeeded: [],
        failed: [],
        skipped: [],
    };
    const { fixable, skipped: notFixable } = await is_supported_1.partitionByFixable(entities);
    handlerResult.skipped.push(...notFixable);
    const ordered = sortByDirectory(fixable);
    const fixedFilesCache = [];
    for (const dir of Object.keys(ordered)) {
        debug(`Fixing entities in directory ${dir}`);
        const entitiesPerDirectory = ordered[dir].map((e) => e.entity);
        const { failed, succeeded, skipped, fixedFiles } = await fixAll(entitiesPerDirectory, options, fixedFilesCache);
        fixedFilesCache.push(...fixedFiles);
        handlerResult.succeeded.push(...succeeded);
        handlerResult.failed.push(...failed);
        handlerResult.skipped.push(...skipped);
    }
    return handlerResult;
}
exports.pipRequirementsTxt = pipRequirementsTxt;
function getRequiredData(entity) {
    const { remediation } = entity.testResult;
    if (!remediation) {
        throw new missing_remediation_data_1.MissingRemediationDataError();
    }
    const { targetFile } = entity.scanResult.identity;
    if (!targetFile) {
        throw new missing_file_name_1.MissingFileNameError();
    }
    const { workspace } = entity;
    if (!workspace) {
        throw new no_fixes_applied_1.NoFixesCouldBeAppliedError();
    }
    return { targetFile, remediation, workspace };
}
exports.getRequiredData = getRequiredData;
async function fixAll(entities, options, fixedCache) {
    const handlerResult = {
        succeeded: [],
        failed: [],
        skipped: [],
    };
    for (const entity of entities) {
        const targetFile = entity.scanResult.identity.targetFile;
        try {
            const { dir, base } = pathLib.parse(targetFile);
            // parse & join again to support correct separator
            if (fixedCache.includes(pathLib.join(dir, base))) {
                handlerResult.succeeded.push({
                    original: entity,
                    changes: [{ success: true, userMessage: 'Previously fixed' }],
                });
                continue;
            }
            const { changes, fixedFiles } = await applyAllFixes(entity, options);
            if (!changes.length) {
                debug('Manifest has not changed!');
                throw new no_fixes_applied_1.NoFixesCouldBeAppliedError();
            }
            fixedCache.push(...fixedFiles);
            handlerResult.succeeded.push({ original: entity, changes });
        }
        catch (e) {
            debug(`Failed to fix ${targetFile}.\nERROR: ${e}`);
            handlerResult.failed.push({ original: entity, error: e });
        }
    }
    return Object.assign(Object.assign({}, handlerResult), { fixedFiles: [] });
}
// TODO: optionally verify the deps install
async function fixIndividualRequirementsTxt(workspace, dir, entryFileName, fileName, remediation, parsedRequirements, options, directUpgradesOnly) {
    const fullFilePath = pathLib.join(dir, fileName);
    const { updatedManifest, changes, appliedRemediation } = update_dependencies_1.updateDependencies(parsedRequirements, remediation.pin, directUpgradesOnly, pathLib.join(dir, entryFileName) !== fullFilePath ? fileName : undefined);
    if (!changes.length) {
        return { changes, appliedRemediation };
    }
    if (!options.dryRun) {
        debug('Writing changes to file');
        await workspace.writeFile(pathLib.join(dir, fileName), updatedManifest);
    }
    else {
        debug('Skipping writing changes to file in --dry-run mode');
    }
    return { changes, appliedRemediation };
}
exports.fixIndividualRequirementsTxt = fixIndividualRequirementsTxt;
async function applyAllFixes(entity, options) {
    const { remediation, targetFile: entryFileName, workspace } = getRequiredData(entity);
    const fixedFiles = [];
    const { dir, base } = pathLib.parse(entryFileName);
    const provenance = await extract_version_provenance_1.extractProvenance(workspace, dir, base);
    const upgradeChanges = [];
    const appliedUpgradeRemediation = [];
    /* Apply all upgrades first across all files that are included */
    for (const fileName of Object.keys(provenance)) {
        const skipApplyingPins = true;
        const { changes, appliedRemediation } = await fixIndividualRequirementsTxt(workspace, dir, base, fileName, remediation, provenance[fileName], options, skipApplyingPins);
        appliedUpgradeRemediation.push(...appliedRemediation);
        upgradeChanges.push(...changes);
        fixedFiles.push(pathLib.join(dir, fileName));
    }
    /* Apply all left over remediation as pins in the entry targetFile */
    const toPin = filterOutAppliedUpgrades(remediation, appliedUpgradeRemediation);
    const directUpgradesOnly = false;
    const fileForPinning = await selectFileForPinning(entity);
    const { changes: pinnedChanges } = await fixIndividualRequirementsTxt(workspace, dir, base, fileForPinning.fileName, toPin, requirements_file_parser_1.parseRequirementsFile(fileForPinning.fileContent), options, directUpgradesOnly);
    return { changes: [...upgradeChanges, ...pinnedChanges], fixedFiles };
}
exports.applyAllFixes = applyAllFixes;
function filterOutAppliedUpgrades(remediation, appliedRemediation) {
    const pinRemediation = Object.assign(Object.assign({}, remediation), { pin: {} });
    const pins = remediation.pin;
    const normalizedAppliedRemediation = appliedRemediation.map((packageAtVersion) => {
        const [pkgName, versionAndMore] = packageAtVersion.split('@');
        return `${standardize_package_name_1.standardizePackageName(pkgName)}@${versionAndMore}`;
    });
    for (const pkgAtVersion of Object.keys(pins)) {
        const [pkgName, versionAndMore] = pkgAtVersion.split('@');
        if (!normalizedAppliedRemediation.includes(`${standardize_package_name_1.standardizePackageName(pkgName)}@${versionAndMore}`)) {
            pinRemediation.pin[pkgAtVersion] = pins[pkgAtVersion];
        }
    }
    return pinRemediation;
}
function sortByDirectory(entities) {
    const mapped = entities.map((e) => (Object.assign({ entity: e }, pathLib.parse(e.scanResult.identity.targetFile))));
    const sorted = sortBy(mapped, 'dir');
    return groupBy(sorted, 'dir');
}
async function selectFileForPinning(entity) {
    const targetFile = entity.scanResult.identity.targetFile;
    const { dir, base } = pathLib.parse(targetFile);
    const { workspace } = entity;
    // default to adding pins in the scanned file
    let fileName = base;
    let requirementsTxt = await workspace.readFile(targetFile);
    const { containsRequire, matches } = await contains_require_directive_1.containsRequireDirective(requirementsTxt);
    const constraintsMatch = matches.filter((m) => m.includes('c'));
    if (containsRequire && constraintsMatch[0]) {
        // prefer to pin in constraints file if present
        fileName = constraintsMatch[0][2];
        requirementsTxt = await workspace.readFile(pathLib.join(dir, fileName));
    }
    return { fileContent: requirementsTxt, fileName };
}
exports.selectFileForPinning = selectFileForPinning;
//# sourceMappingURL=index.js.map